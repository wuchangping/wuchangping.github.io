<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#1D2D2D">
    <meta name="msapplication-TileColor" content="#1D2D2D">
    
    
    
    <meta name="keywords" content="flink, pravega, kubernetes, docker, streaming, storage">
    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    
    
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    
    
    <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#1D2D2D">
    
    
    <link rel="manifest" href="/favicons/site.webmanifest">
    
    
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    
    
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    
    <link rel="stylesheet" type="text/css" href="/css/sidebar.css">
    
    
<link rel="stylesheet" type="text/css" href="/css/page.css">
<link rel="stylesheet" type="text/css" href="/css/post.css">

    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link rel="stylesheet" type="text/css" href="/css/atom-one-dark.css">
    <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css">
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script defer type="text/javascript" src="/js/util.js"></script>
    <script defer type="text/javascript" src="/js/scrollspy.js"></script>
    <script defer type="text/javascript" src="/js/fontawesome-all.min.js"></script>
    <script defer type="text/javascript" src="/js/lightgallery.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-fullscreen.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-hash.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-pager.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-thumbnail.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-zoom.min.js"></script>
    
    <script defer src="/js/busuanzi.pure.mini.js"></script>
    
    
    
    <script defer type="text/javascript" src="/js/index.js"></script>
    
    <script defer type="text/javascript" src="/js/custom.js"></script>
    <title>常平的技术博客 - 技术是有生命的，因为它可以进化</title>
  </head>
  <body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"  data-spy="scroll" data-target=".list-group">
    
<header id="header" class="header" style="background: #1D2D2D;">
  <div class="container">
    <div class="header-container">
      <div class="header-title">
        <h1 class="title"><a href="/">常平的技术博客</a></h1>
        <h2 class="subtitle">www.changping.me</h2>
      </div>
      
      <div class="logo">
        <img src="/images/logo.png" alt="logo">
      </div>
      
    </div>
    <nav id="nav" class="nav">
      <a id="nav-toggle" class="nav-toggle" aria-hidden="true"><i class="fas fa-bars" aria-label="切换导航栏"></i></a>
      <ul id="menu" role="menubar" aria-hidden="false">
        
        <li role="menuitem"><a href="/" class="current">首页</a></li>
        
        <li role="menuitem"><a href="/archives">全部</a></li>
        
        <li role="menuitem"><a href="/categories">分类</a></li>
        
        <li role="menuitem"><a href="/tags">标签</a></li>
        
        <li role="menuitem"><a href="/about">关于</a></li>
        
      </ul>
    </nav>
  </div>
</header>


    <main id="main" class="main">
      <div class="container">
        <div class="main-container">
          <div class="content">
            

<div id="index" class="index page">
  
  <article class="article post card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="www.changping.me/2020/10/25/distributed-product_the_customer_and_technology/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="常平">
        <meta itemprop="description" content="“分布式系统架构设计师”">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="常平的技术博客">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2020/10/25/distributed-product_the_customer_and_technology/" itemprop="url">分布式系统架构设计 – 第25式- 让技术回归常识,先有客户再有技术</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2020-10-25T20:55:00+08:00">2020-10-25 20:55:00</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/product/" itemprop="url" rel="index"><span itemprop="name">product</span></a></span>
        </span>
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h2 id="先有客户再有技术"><a href="#先有客户再有技术" class="headerlink" title="先有客户再有技术"></a><font color="#FF8C00">先有客户再有技术</font></h2><p>技术不同于科学，科学是人类对自然的认知，它可以很前沿很理论也不用讲究工程价值，而技术更多指的是功能与工程得实现，更需要关注的是“利他”的常识。技术人员其比较关注的是技术架构、实现方式、技术价值以及开发成本，而比较容易忽略客户需求、使用场景以及产品价值与用户体验。忽略这些产品相关的内容而维技术论就容易犯错进而浪费有限的开发资源，在工程实现上维技术论常见的有四错：</p>
<ul>
<li>第一错：“我为用户想”，这是研发人员最容易犯的错，其已经有用户意识，但是却没有进一步与用户沟通，直接替用户做决定，也不清楚用户的使用场景，因此容易造成”所想“实际上并不是用户真正所想；</li>
<li>第二错：追求有挑战的技术而非技术的实用价值，也非从合适的解决用户问题的角度出发，将技术上的自嗨当成客户需求，比如用户需要从A地到B地，简单一点给用户一辆自行车就可以解决的问题，而技术自嗨就容易非要先自行造个飞机，然后拼命的给用户推销这个好这个快，但是用户却不买单；</li>
<li>第三错：维性价比论，总以为又便宜的又好的就是真的好，性价比是大杀器，但是很多情况下其实客户也讲ROI(投入产出比)，比如双11秒杀活动，用户可以不计成本的采用最新进最前沿的技术，只要能扛得住双11的流量就可以不计成本，因为再大的成本，跟双11带来的收益对比都是毛毛雨；</li>
<li>第四错：闭门造车，不实事求是，不与客户做探讨，不做调查就把想象的或还处于概念上的东西当成客户需求。</li>
</ul>
<p>因此，架构人员不能维技术论，维技术论就不是一个合格的架构师，架构师还需要关注客户价值，在实现一个架构之前先确定这个是对客户有价值的，同时平衡好客户价值与技术前沿之间的取舍关系。</p>
<h2 id="什么是客户，又什么是客户价值"><a href="#什么是客户，又什么是客户价值" class="headerlink" title="什么是客户，又什么是客户价值"></a><font color="#FF8C00">什么是客户，又什么是客户价值</font></h2><h3 id="什么是客户"><a href="#什么是客户" class="headerlink" title="什么是客户"></a>什么是客户</h3><p>用英文单词表示，客户与用户其实是比较容易区别的，客户是 customers, 用户 是users，而中文二者都有个“户”字就比较容易混淆。To C产品客户可以是用户，但是To B产品， 客户却不是就等于就是用户。狭义的客户 = 买单的，广义上的客户 = 客户的客户 + 客户 + 客户的用户 + 利益链上的所有，用户也不就是一个角色或者某人，对to B产品来说，用户的本质是“需求“的集合。</p>
<h3 id="什么是客户价值"><a href="#什么是客户价值" class="headerlink" title="什么是客户价值"></a>什么是客户价值</h3><p>“任何先进的技术、产品和解决方案，只有转化为客户的商业成功才能产生价值“ [1]  ，客户价值就是对客户有用的东西，价值来源于价值的交换。技术的目的就是做对客户有用的东西，并且技术的进化方向是由市场所决定的。</p>
<p>以客户为中心，就是给客户创造价值，替解决用户难点、痛点、挑战点、为客户提供高质量低成本的产品，同时响应要及时。病根是需，药是求，拿出 “求” 解决 “需”，药到病除就是为客户创造价值[1]。</p>
<h2 id="如何做到以客户价值为中心？"><a href="#如何做到以客户价值为中心？" class="headerlink" title="如何做到以客户价值为中心？"></a><font color="#FF8C00">如何做到以客户价值为中心？</font></h2><p>认知上做到技术要先从客户价值开始，那么执行上应该如何拆分？使得认知具有可量化的执行性？这里从以下三个方面对“如何做到以客户价值为中心”这个问题进行拆解：</p>
<ul>
<li>价值探索 - 价值与交付双轮驱动思维模型，PMF-MVP思维模型</li>
<li>价值确定 - 三三制需求分析思维模型</li>
<li>价值输出 - 卡诺需求分级与分类思维模型</li>
</ul>
<h3 id="价值探索1-双轮驱动思维模型"><a href="#价值探索1-双轮驱动思维模型" class="headerlink" title="价值探索1 - 双轮驱动思维模型"></a>价值探索1 - 双轮驱动思维模型</h3><p><img src="https://wuchangping.oss-cn-hangzhou.aliyuncs.com/product/25/double-ring.png" alt="双轮驱动思维模型"></p>
<p>价值探索的方法论之一是双轮驱动思维模型，其原则为：</p>
<ul>
<li>以客户价值为前轮，前轮把握方向，解决的是需求探索、价值确定、特性探讨以及价值精炼的过程，需求输出需要去伪存真、去粗纯精、过滤提炼；</li>
<li>产品交付为后轮，后轮提供驱动力，解决的是开发、测试、运维以及获取客户反馈；</li>
<li>先有客户价值再有产品交付，客户价值又可分为主动式客户价值与被动式客户价值，获取客户需求的方式也需要合理取舍；</li>
<li>在双轮驱动模型里，二者谁都离不开谁，不是厚此薄彼的关系，而是二者互相协作从而推动产品往商业成功这个目标前进的关系；</li>
</ul>
<h3 id="价值探索2-PMF-MVP-开发模型"><a href="#价值探索2-PMF-MVP-开发模型" class="headerlink" title="价值探索2 - PMF-MVP 开发模型"></a>价值探索2 - PMF-MVP 开发模型</h3><p><img src="https://wuchangping.oss-cn-hangzhou.aliyuncs.com/product/25/pmf-mvp.png" alt="PMF-MVP"></p>
<p>如上图所示，PMF（Product-Market Fit）是讲究产品与市场匹配，是产品需要与市场需求相匹配，而MVP （Minimal Viable Product）是 最小可用产品，MVP讲的是每个版本的迭代都是一个可用的产品而非功能的堆砌，PMF-MVP开发法，讲究快速给的输出可用的版本给到客户，再由客户进行使用获取客户的信息反馈，再进行版本迭代。</p>
<p>价值探索的方法论之二是PMF-MVP开发法，其原则为：</p>
<ul>
<li>PMF-MVP 开发法可以帮助团队在早期快速确认客户的真实需求；从特性列表中确定产品（特性）的基本功能， 然后迅速开发MVP，再投放市场提前踩坑，收集用户反馈，然后再进行产品迭代，只有用户用起来，产品才有机会演化；</li>
<li>做MVP的时候，不是验证产品好不好用，而是验证产品/特性是不是用户真的想要的，减少开发成本，“闭门造车”式的开发经常会遇到“再来一次”;</li>
<li>跟目标用户产生互动和连接，每一步都收集用户的反馈，前期跟客户多交流，多沟通，“一元共创”与用户一起成长。</li>
</ul>
<p>在价值探索之后就需要进行价值确定。</p>
<h3 id="价值确定-–-三三制需求分析思维模型"><a href="#价值确定-–-三三制需求分析思维模型" class="headerlink" title="价值确定 – 三三制需求分析思维模型"></a>价值确定 – 三三制需求分析思维模型</h3><p><strong>公式： 需求</strong> <strong>=</strong> <strong>需（痛点、难点、挑战点、恐惧点）</strong> <strong>+</strong> <strong>求 （产品、服务或解决方案）</strong>， 需即痛点、难点、挑战点，求即解决方案、产品或服务，求到需即完成，这就是有客户价值。依据三三制需求分析思维模型我们可以进行价值确定，三三制需求分析思维模型是一个价值确定思维模型，其如下表：</p>
<table>
<thead>
<tr>
<th><strong>类别</strong></th>
<th><strong>功能</strong></th>
<th><strong>质量</strong></th>
<th><strong>约束</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>“大”**</strong>客户**</td>
<td>业务目标：  商业成功，比如科技向善</td>
<td>业务质量：    多、快、好、省</td>
<td>业务约束：  时间、质量、成本，法律法规，信息安全，技术趋势，竞争对手，行业标准等</td>
</tr>
<tr>
<td><strong>“大”**</strong>用户**</td>
<td>业务需求</td>
<td>运行时质量：  性能、可用性、可靠性，可伸缩性、可观测性、可运维性、易用性、兼容性、安全性等</td>
<td>使用时约束：  遗留系统，业务环境，用户能力，用户群特征等</td>
</tr>
<tr>
<td><strong>“大”**</strong>团队**</td>
<td>功能需求：  基本功能P0  、增值功能P1、潜在功能P2 、可有可无功能P3  、有害无益功能P100</td>
<td>编程时质量：  可扩展，可读性，可测试性，可维护性，可移植性</td>
<td>编程时约束：  开发进度，资源预算、上级要求、开发团队能力、产品规划、运行环境</td>
</tr>
</tbody>
</table>
<p>三三制需求分析思维模型进行价值确定之后即价值输出。</p>
<h3 id="价值输出-–-卡诺需求分类与分级思维模型"><a href="#价值输出-–-卡诺需求分类与分级思维模型" class="headerlink" title="价值输出 – 卡诺需求分类与分级思维模型"></a>价值输出 – 卡诺需求分类与分级思维模型</h3><p><img src="https://wuchangping.oss-cn-hangzhou.aliyuncs.com/product/25/kano-model.png" alt="KANO"></p>
<p>这里采用KANO需求分类与分解思维模型进行价值输出，依据kano模型，需求可以分为：</p>
<ul>
<li>基本需求：必须有的最根本的需求，没这个根本就没法谈，会阻塞产品交付；</li>
<li>增值需求：当提供此需求时用户满意度会提升；当不提供此需求时用户满意度会降低；</li>
<li>竞争力需求：若不提供此需求，用户满意度不会降低；若提供此需求，用户满意度会有所的提升，属于亮点要素；</li>
<li>可有可无需求：用户根本不在意的需求，对用户体验毫无影响；</li>
<li>有害无益需求：提供后用户满意度反而下降；</li>
</ul>
<p>卡诺模型将需求进行了分级与分类，进一步的区分了需求的价值。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><font color="#FF8C00">小结</font></h2><p>本文首先确定了 “先有客户再有技术”的认知，再讲述了什么是客户，什么是客户价值，并且以思维模型的方式讲述了如何做到以客户价值为中心。日拱一卒，功不唐捐，分享是最好的学习，与其跟随不如创新，希望这个思维模型对大家有用。另作者能力与认知都有限，”我讲的，可能都是错的“，欢迎大家拍砖留念。</p>
<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a><font color="#FF8C00">作者简介</font></h2><p>常平，中科大硕，某AI独角兽深度学习首席软件工程师，前EMC 大数据资深首席工程师，主要工作背景在深度学习、流式大数据、云计算、分布式中间件以及Linux内核。</p>
<h2 id="版权申明"><a href="#版权申明" class="headerlink" title="版权申明"></a><font color="#FF8C00">版权申明</font></h2><p>本文的版权协议为 CC-BY-NC-ND license：<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh</a></p>
<p>在遵循署名、非商业使用（以获利为准）以及禁止演绎的前提下可以自由阅读、分享、转发、复制、分发等。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><font color="#FF8C00">参考资料</font></h2><p>[1] xx增长法</p>

      
    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/product/" rel="tag"><i class="fas fa-tags"></i>product</a>
        
      </div>
      
    </footer>
  </article>
  
  <article class="article post card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="www.changping.me/2020/09/26/distributed-product-how-to-write-a-architecture-document/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="常平">
        <meta itemprop="description" content="“分布式系统架构设计师”">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="常平的技术博客">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2020/09/26/distributed-product-how-to-write-a-architecture-document/" itemprop="url">分布式系统架构设计 – 第24式- 如何撰写一个好的架构设计文档</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2020-09-26T11:11:25+08:00">2020-09-26 11:11:25</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/product/" itemprop="url" rel="index"><span itemprop="name">product</span></a></span>
        </span>
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h2 id="为什么需要写文档"><a href="#为什么需要写文档" class="headerlink" title="为什么需要写文档"></a><font color="#FF8C00">为什么需要写文档</font></h2><p>软件工程师有两大难：1，没有文档；2，写文档。设计文档是用于描述如何去解决一个产品或特性的问题的，好的设计文档可以确保正在做的是正确的事情。</p>
<p>架构设计文档通常又可以分成概要设计文档以及详细设计文档。概要设计文档把握产品架构的宏观方向，而详细设计文档确定微观的代码实现。通常详细设计文档应该由具体负责这个模块实现的人员来完成，只有负责代码落地的人员才最清楚具体的微观问题，其他人员可以参与审阅设计方案、把握正确的方向。在工作中经常会遇到这样的情况：设计人员写完详细设计文档再把文档交付给写代码的人，去要求按这个文档写代码，经常会遇到的矛盾是：负责具体写代码的人觉得这个文档脱离实际没价值，而写文档的人又指责写代码的人员不理解他的意图。 因此，比较合适的方案是 谁负责写代码谁就负责详细设计（这对技术人员的能力要求也较高），其他人员提供检阅与建议，把握风险与方向。</p>
<p>那么如何撰写一个好的架构设计文档呢？这里提出一个常用的架构设计模板，以供参考，如下：</p>
<h2 id="架构设计文档模板"><a href="#架构设计文档模板" class="headerlink" title="架构设计文档模板"></a><font color="#FF8C00">架构设计文档模板</font></h2><h3 id="动机介绍"><a href="#动机介绍" class="headerlink" title="动机介绍"></a>动机介绍</h3><p>描述需要完成的内容，介绍上下文以及需要达到的目标。</p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>以三三制需求分析模型分析客户、用户以及团队的功能、质量与约束需求，首要方针是“价值优先”。</p>
<table>
<thead>
<tr>
<th><strong>类别</strong></th>
<th><strong>功能</strong></th>
<th><strong>质量</strong></th>
<th><strong>约束</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>“大”客户</td>
<td>业务目标：  商业成功</td>
<td>业务质量：    多、快、好、省</td>
<td>业务约束：  时间、质量、成本，法律法规，信息安全，技术趋势，竞争对手，行业标准等</td>
</tr>
<tr>
<td>“大”用户</td>
<td>业务需求：比如AI模型训练</td>
<td>运行时质量：  精度、线性度、收敛性，性能、可用性、可靠性，可伸缩性、可观测性、可运维性、易用性、兼容性、安全性</td>
<td>使用时约束：  遗留系统，业务环境，用户能力，用户群特征等</td>
</tr>
<tr>
<td>“大”团队</td>
<td>功能需求：  基本功能P0  、增值功能P1、潜在功能P2 、可有可无功能P3  、有害无益功能P100</td>
<td>编程时质量：  可扩展，可读性，可测试性，可维护性，可移植性</td>
<td>编程时约束：开发进度，资源预算、上级要求、开发团队能力、产品规划、运行环境</td>
</tr>
</tbody>
</table>
<h3 id="目标非目标"><a href="#目标非目标" class="headerlink" title="目标非目标"></a>目标非目标</h3><p>目标与非目标主要是解释本文档做什么与不做什么，定义需要完成的任务与约束边界。</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">目标：定义本设计文档需要解决的问题以及需要达到的质量指标，是说明需要做什么。<br><br>非目标：说明本设计文档的约束，是说明不做什么。<br></code></pre></td></tr></table></figure>
<h3 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h3><p>计划本身是“无用”的，但是没有计划却是万万不能，通过制定里程碑可以让文档的其他用户知道项目所需要的大概的时间周期。例如，可以按如下格式定义里程碑：</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">开工日期：2020年10月10日<br>里程碑 1 - 2020年10月30日，完成概要设计文档<br>里程碑 2 - 2020年11月30日，完成详细设计文档，并且编写完代码<br>结束日期: 2020年12月30日，完成自我测试、文档、质量保证以及特性交付<br></code></pre></td></tr></table></figure>
<h3 id="设计哲学"><a href="#设计哲学" class="headerlink" title="设计哲学"></a>设计哲学</h3><p>产品的设计哲学是产品的宪法，也是产品的灵魂与价值观，是产品的不可违背的最高指导思想，其把握了架构设计的方向，例如:</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">设计哲学<br> - 以客户价值为中心<br> - 以持续创新为竞争力<br></code></pre></td></tr></table></figure>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>架构交付的是功能需求，但是真正的差距体现在非功能需求（质量与约束），因此可以通过制定设计原则确定产品的非功能要素，设计原则是产品的法则，也是架构取舍的依据，例如:</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">设计原则<br>- 最佳物种原则<br>- 高内聚低耦合原则<br>- 可用性原则<br>- 可靠性原则<br>- 稳定性原则<br>- 可服务化原则<br>- 兼容性、可迁移原则<br>- 服务化、组件化<br>- 接口隔离与服务自治<br>- 用户触达成本原则<br>- 用户体验原则<br>- 持续演进原则<br></code></pre></td></tr></table></figure>
<h3 id="设计提案"><a href="#设计提案" class="headerlink" title="设计提案"></a>设计提案</h3><p>设计提案可以从三个方面进行考虑：客户想要的、对手怎么做以及自身打算怎么进行，还需要分析每个方案的优点、缺点以及方案取舍的依据。</p>
<h4 id="当前提案"><a href="#当前提案" class="headerlink" title="当前提案"></a>当前提案</h4><p>当前方案需要分当前已有的提案、也可包括当前竞争对手的方案，以及客户/用户所期待的方案。</p>
<h4 id="自身提案"><a href="#自身提案" class="headerlink" title="自身提案"></a>自身提案</h4><p>提出自身的设计方案，可以提出多个设计方案：比如 提案1，提案2等，确定大的架构设计方向。</p>
<h4 id="提案比较"><a href="#提案比较" class="headerlink" title="提案比较"></a>提案比较</h4><p>提出以上方案后，制定技术提案评审表，分析提案的优缺点，确定最终的可选方案。</p>
<h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p>这一部分是最重要、最核心的内容，属于架构设计文档的核心。在确定设计提案后进行概要设计，通常可以采用 4+1 架构设计法完成这一部分内容。如下图：</p>
<p><img src="https://wuchangping.oss-cn-hangzhou.aliyuncs.com/product/product-how-to-write-arch-document.png" alt="4+1视图"></p>
<p>常用的4+1视图涵盖有物理视图、逻辑视图、处理视图、开发视图以及用例视图，其中与用例视图交叉的部分是描述共同的细节，同时每种视图中又有各自的需求，例如：</p>
<ul>
<li>物理视图关注安装、部署、升级、运维的需求；</li>
<li>逻辑视图关注架构设计的功能需求；</li>
<li>处理视图关注非功能里的用户运行质量需求；</li>
<li>开发视图关注团队的开发质量需求；</li>
</ul>
<h3 id="跨团队影响"><a href="#跨团队影响" class="headerlink" title="跨团队影响"></a>跨团队影响</h3><p>这里阐述需要的团队依赖以及对其他团队的影响。</p>
<h3 id="详细的交付计划"><a href="#详细的交付计划" class="headerlink" title="详细的交付计划"></a>详细的交付计划</h3><p>这里可以以表格的方式，制定详细的交付计划。</p>
<h3 id="开放问题讨论"><a href="#开放问题讨论" class="headerlink" title="开放问题讨论"></a>开放问题讨论</h3><p>提出需要讨论的问题。</p>
<h3 id="作者与评审人员"><a href="#作者与评审人员" class="headerlink" title="作者与评审人员"></a>作者与评审人员</h3><p>确定作者与评审人员信息，例如：</p>
<table>
<thead>
<tr>
<th>类目</th>
<th>修改</th>
<th>时间</th>
<th>作者</th>
<th>评审</th>
</tr>
</thead>
<tbody>
<tr>
<td>类目 1</td>
<td>init</td>
<td>2020/09/26</td>
<td>xxxxxxxxx</td>
<td>xxxxxxxxx</td>
</tr>
<tr>
<td>类目 2</td>
<td>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</td>
<td>xxxxxxxxxxx</td>
<td>xxxxxxxxx</td>
<td>xxxxxxxxxx</td>
</tr>
<tr>
<td>类目 3</td>
<td>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</td>
<td>xxxxxxxxxxx</td>
<td>xxxxxxxxxx</td>
<td>xxxxxxxxxxx</td>
</tr>
</tbody>
</table>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><font color="#FF8C00">小结</font></h2><p>本文提出了一个常用的架构设计模板，希望这个设计模板对大家有用。另作者能力与认知都有限，”我讲的，可能都是错的“[1]，欢迎大家拍砖留念。</p>
<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a><font color="#FF8C00">作者简介</font></h2><p>常平，中科大硕，某AI独角兽深度学习首席软件工程师，前EMC 大数据资深首席工程师，主要工作背景在深度学习、流式大数据、云计算、分布式中间件以及Linux内核。</p>
<h2 id="版权申明"><a href="#版权申明" class="headerlink" title="版权申明"></a><font color="#FF8C00">版权申明</font></h2><p>本文的版权协议为 CC-BY-NC-ND license：<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh</a></p>
<p>在遵循署名、非商业使用（以获利为准）以及禁止演绎的前提下可以自由阅读、分享、转发、复制、分发等。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><font color="#FF8C00">参考资料</font></h2><p>[1] <a href="https://www.freecodecamp.org/news/how-to-write-a-good-software-design-document-66fcf019569c/" target="_blank" rel="noopener">https://www.freecodecamp.org/news/how-to-write-a-good-software-design-document-66fcf019569c/</a></p>

      
    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/product/" rel="tag"><i class="fas fa-tags"></i>product</a>
        
      </div>
      
    </footer>
  </article>
  
  <article class="article post card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="www.changping.me/2020/08/30/distributed-ideamodel-singularity_action/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="常平">
        <meta itemprop="description" content="“分布式系统架构设计师”">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="常平的技术博客">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2020/08/30/distributed-ideamodel-singularity_action/" itemprop="url">分布式系统架构设计 – 第23式- 产品创新与宇宙奇点大爆炸</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2020-08-30T20:40:41+08:00">2020-08-30 20:40:41</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/product/" itemprop="url" rel="index"><span itemprop="name">product</span></a></span>
        </span>
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h2 id="什么是奇点"><a href="#什么是奇点" class="headerlink" title="什么是奇点"></a><font color="#FF8C00">什么是奇点</font></h2><p>物理学认为宇宙从无到有始于一个点，这个点叫做“奇点”，它积聚了形成现有宇宙中所有物质的势能，当这一个点的能量平衡被破坏后，宇宙大爆炸发生，从而生成我们现在的宇宙。如果把宇宙比作我们的产品，奇点就是这个产品赖以出现与存在的关键点。</p>
<h2 id="产品创新与奇点理论"><a href="#产品创新与奇点理论" class="headerlink" title="产品创新与奇点理论"></a><font color="#FF8C00">产品创新与奇点理论</font></h2><h3 id="一个问题"><a href="#一个问题" class="headerlink" title=" 一个问题"></a><font color="#008C"> 一个问题</font></h3><p>奇点是这个产品赖以出现与存在的关键点，那么第一个需要回答的问题是：“你的产品的奇点是什么？”。一个企业就是一个产品，那么使命就是这个企业的第一原理点，价值观就是这个企业的奇点，是这个企业赖以存在的关键点。一个软件平台是一个产品，那么以客户为中心可以是这个产品的第一原理点，逻辑基石可以使这个产品的奇点，这个基石是这个产品赖以生存的关键点。</p>
<p>因此将奇点理论应用于产品创新的第一个关键步骤在于 找出你的产品的”逻辑奇点“，比如在AI训练市场，GPU是原来的产品的奇点，是原有的产品赖以依存的关键点，而XPU就是新生的产品的奇点，是新生产品赖以生存的基石，他们的第一原理都是客户的AI训练。</p>
<h3 id="两重境界"><a href="#两重境界" class="headerlink" title="两重境界"></a><font color="#008C">两重境界</font></h3><blockquote>
<p>创新 = 更好 | 不同 | 新生</p>
</blockquote>
<ul>
<li><p><strong>更好，</strong>指的是市场是明确存在需求的，但是提供的新产品在质量、功能、渠道、价格等方面比原有产品更具优势，是用更好的体验来满足客户的真需求；</p>
</li>
<li><p><strong>不同，</strong>指的是差异化竞争，”与其更好不如不同”，不同不只是技术面的不同，而是处处差异化不同，理念、技术、渠道，运营，销售等处处差异化竞争；</p>
</li>
<li><p><strong>新生，</strong>指的是 从0到1，从无到有的创造一个新物种，是指用凭空创造出一个新产品来满足客户需求，这种形态的产品要么是颠覆式的创造带来巨大的商业上的成功，要么就是没有真实客户需求的新事物，商业上完全失败。</p>
</li>
</ul>
<p>这里，AI训练芯片采用的是“<strong>更好与不同”</strong>这两个产品创新方法论，组合原有的技术开拓出新产品，规避风险，满足客户真实的需求。从GPU到XPU 体现的是“不同”的创新理念，而从XPU1.0到 XPU 2.0 再到N.0 体现的是“更好”的创新理念。</p>
<p>因此，这里提出：<strong>创新的第一重境界是“与其更好不如不同”，第二重境界是“与其不同不如更好”</strong>。</p>
<h4 id="与其更好不如不同"><a href="#与其更好不如不同" class="headerlink" title=" 与其更好不如不同"></a><font color="#00CED1"> 与其更好不如不同</font></h4><p>生物学家通过分析人与猩猩的遗传基因发现人与猩猩的基因相比较仅有约1.2%的差异，但是就是这约1.2%的差异却造就出两个完全不同的物种以及生态位，猩猩呆树上吃果子，人类败走树上行走平地却成了万物之灵长。决定你是猩猩还是人类的差异只有那约1.2%的差异而已。</p>
<p>“与其更好不如不同”这句话讲的是错位竞争，远古时期要是人类跟猩猩拼命的争树上的好位置，做得再好也不过还是猩猩，也许如今都还在树上跟别的猩猩抢香蕉而已，但是，人类不跟猩猩争抢树上的位置，其不爬树了，开始出走平原，环境因素逼迫其直立行走进而进化成万物之灵长。</p>
<p><img src="https://wuchangping.oss-cn-hangzhou.aliyuncs.com/product/qidian_product_model_1.PNG" alt="与其更好不如不同"></p>
<p>同样的道理，在AI训练芯片的产品市场里，如上图之左，GPU是其奇点，它有自己的生态位，有自己的壁垒，也有自己的第一原理点。一款产品要是跟GPU抢占同样的生态位，做得好也还在它的那个圈圈里，后来者再怎么的努力也难以突破它的那个圈圈。然而错位竞争，从GPU到XPU，击破GPU的奇点位置，从新定义自己的那个壁垒与圈圈，却使得产品有了新的生态位，新的可能。</p>
<h4 id="与其不同不如更好"><a href="#与其不同不如更好" class="headerlink" title=" 与其不同不如更好"></a><font color="#00CED1"> 与其不同不如更好</font></h4><p><img src="https://wuchangping.oss-cn-hangzhou.aliyuncs.com/product/qidian_product_model_2.PNG" alt="与其不同不如更好"></p>
<p>“与其不同不如更好”讲的是在重新定义好自己的奇点后，再进行进化，从奇点1.0到奇点2.0，再到奇点3.0。人类的进化也是经历了猿人类、原始人类、智人类、现代人类这四个阶段，体现的是一步步的更好。而不是一会不同成猩猩、一会不同成大鱼、一会不同成大鸟，这样永远难以出现代人类，或者需要多付出几百万年的代价才能得到现在的结果。</p>
<p>在AI训练芯片重新定义了自己XPU的奇点之后，需要的是以“市场需求”为进化的引力与方向，从XPU1.0到XPU2.0再到XPU3.0，从而才能进化出未来的XPU N.0。</p>
<h3 id="三个步骤"><a href="#三个步骤" class="headerlink" title="三个步骤"></a><font color="#008C">三个步骤</font></h3><p>如上面两图里的”奇点下移，破界创新“，依据奇点理论进行创新的步骤是奇点破界的三个步骤：<strong>“破坏，外延，重生”</strong>：</p>
<p>1，破坏，找到产品奇点并加以破坏。产品缺点不是奇点，奇点是产品赖以出现与存在的点，找到它，然后破坏它，类似于使得宇宙奇点能量失去平衡；</p>
<p>2，外延，产品奇点下移，产品边界外延，类似于宇宙大爆炸从而造成宇宙边界外延；</p>
<p>3，重生，重构产品奇点，形成新的产品体系，类似于新宇宙的形成。</p>
<p> 以AI训练芯片的创新为例，这里只涉及技术面的创新，销售、渠道、运营、管理、商业模式等方面的创新不在本文范围。可以知道的是目前市面上的AI芯片的最大竞争对手是GPU，对其应用奇点创新思维模型的步骤有：</p>
<p>1， 破坏，找出产品奇点，然后破坏它的奇点。例如，我们知道GPU的赖以依存的关键点有：提供图像视频处理功能，依赖于图像视频横向扩展出AI训练功能，依据初代版本时间点的硬件特性进行软件的设计；</p>
<p>2，外延，产品奇点下移，破界，新的产品边界外延。针对以上GPU的三条关键点，提出AI芯片的新奇点：去除图像视频的处理功能简化软硬件的设计，从而节约成本。抓住技术进步的福利，去除历史包裹，依据当前最新的软硬件特性进行产品设计，使之更符合现代的市场需求；</p>
<p>3， 重生，最后更新的、更具有成本竞争力以及技术竞争力的、针对AI训练而实现的新产品”XPU“诞生。</p>
<p>这一套创新思维模型的关键点在于找出原有的产品赖以出现以及存在的“奇点”，然后破界重生。</p>
<h2 id="阿基米德产品思维模型"><a href="#阿基米德产品思维模型" class="headerlink" title="阿基米德产品思维模型"></a><font color="#FF8C00">阿基米德产品思维模型</font></h2><p>阿基米德产品思维模型灵感来自于阿基米德的一句话:”给我一个支点,我可以撬起地球。“，因此我定义它为阿基米德产品思维模型，奇点创新思维模型是 阿基米德产品思维模型的子集，如下图：</p>
<p><img src="https://wuchangping.oss-cn-hangzhou.aliyuncs.com/product/ajimide_product_model.PNG" alt=""></p>
<p>在阿基米德产品思维模型里产品是一个圆，圆内的三角形是打造产品所需的技术，在产品圆里除了技术三角、还补充了企业文化、企业制度以及组织结构这三个要素，在圆之外还有奇点、壁垒、价值网以及一个支点、一个杠杆、一个作用力。</p>
<p>在这个模型里，支点可以认为是“以客户为中心”，关键能力可以是团队也可以是资本，还可以是二者的组合，产品离客户越远，需要的作用力就越大，产品离客户越近，需要的作用力就越小。企业文化、制度、组织关系是产品的关键要素，但不是决定要素，技术才是产品打造的决定要素，其面积占产品圆的近2/3，狭义上的技术指的是技能，但这里的技术不是，它是广义的，其涵盖：大势、理念、方法论、技能、工具与边界。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><font color="#FF8C00">小结</font></h2><p>本文结合奇点理论讲述了产品的创新思维模型，日拱一卒，功不唐捐，分享是最好的学习，与其跟随不如创新，希望这个思维模型对大家有用。另作者能力与认知都有限，”我讲的，可能都是错的“[1]，欢迎大家拍砖留念。</p>
<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a><font color="#FF8C00">作者简介</font></h2><p>常平，中科大硕，某AI独角兽深度学习首席软件工程师，前EMC 大数据资深首席工程师，主要工作背景在深度学习、流式大数据、云计算、分布式中间件以及Linux内核。</p>
<h2 id="版权申明"><a href="#版权申明" class="headerlink" title="版权申明"></a><font color="#FF8C00">版权申明</font></h2><p>本文的版权协议为 CC-BY-NC-ND license：<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh</a></p>
<p>在遵循署名、非商业使用（以获利为准）以及禁止演绎的前提下可以自由阅读、分享、转发、复制、分发等。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><font color="#FF8C00">参考资料</font></h2><p>[1]《第二曲线创新》 李善友</p>

      
    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/product/" rel="tag"><i class="fas fa-tags"></i>product</a>
        
      </div>
      
    </footer>
  </article>
  
  <article class="article post card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="www.changping.me/2020/08/28/distributed-product_and_producibility/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="常平">
        <meta itemprop="description" content="“分布式系统架构设计师”">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="常平的技术博客">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2020/08/28/distributed-product_and_producibility/" itemprop="url">分布式系统架构设计 – 第22式 - 什么是产品以及如何将一个开源软件项目产品化</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2020-08-28T15:23:38+08:00">2020-08-28 15:23:38</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/product/" itemprop="url" rel="index"><span itemprop="name">product</span></a></span>
        </span>
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a><font color="#FF8C00">导言</font></h2><p>架构师是业务与产品之间的桥梁，其应该具备技术与产品的商业意识并且需要有将技术转化为产品的能力。而当前软件架构师在工作过程中往往离不开开源的软件项目，因此经常面临两个问题：”什么是产品？“以及“如何将一个开源的软件项目产品化？”</p>
<p>一套科学技术分析方法的背后有一定有着深刻的理论基础和哲学背景。找到了这套技术分析的源头，才能从本质上把握这套技术，看清其全貌，明了其长处和短处，这样在具体应用中，才能得心应手，提高胜算，并不断的丰富和发展这套技术。基于此，本文提出了一套如何将开源软件项目产品化的方法论。</p>
<p>然而理论与实践是相互作用的，宏观角度知道方法论之后还需要从微观上进行实践，不然就如同知道很多道理却过不好这一生，知道很多原则却写不好代码一样一样的。</p>
<h2 id="什么是产品"><a href="#什么是产品" class="headerlink" title="什么是产品"></a><font color="#FF8C00">什么是产品</font></h2><p>产品的定义：</p>
<blockquote>
<p>产品是指做为商品提供给市场，被人们使用和消费，并能满足人们某种需求的任何东西，包括有形的物品、无形的服务、组织、观念或它们的组合。</p>
</blockquote>
<p>从产品的定义中我们可以看到以下几点：</p>
<ul>
<li><p>属性：有形的物品、无形的服务、组织、观念或它们的组合，因此产品自带有形或无形属性；</p>
<ul>
<li>有形属性：狭义上产品是被生产出的能满足人们需求的具有物理属性的有形的物品。在绝大多数人的认知里，对产品的理解是停留在这一层次的，产品具有看得见、摸得着的物理形态；</li>
<li>无形属性：广义上产品是可以满足人们需求的任何东西，无形的服务、组织、观念或者它们的组合也是产品。广义上的产品定义对人的认知有更高的要求。服务是产品、企业是产品、团队是产品、认知是产品、本文是产品，这些东西的组合也是产品。万物皆产品，它目前不是产品，那只是没被产品化、或者不在对的时间与空间里；</li>
</ul>
</li>
<li><p>价值：产品首先是商品，其具有交易的价值，能提供给市场，供人们使用与消费，所有不能交易的东西不在产品的定义范围之内，因此这里可以推导出产品是具有价值的，没有价值的东西不属于产品的范畴；</p>
</li>
<li>交易：产品是做为商品提供给市场，被人们使用和消费，因此具有交易的价值，能满足市场的某种需求；</li>
</ul>
<p>因此基于以上的产品的公理化定义以及定理化推导得出产品的第一性原理定义：</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">产品 = 属性 + 价值 + 交易<br></code></pre></td></tr></table></figure>
<p>从以上公式中可以认为产品是<font color="#FF8C00"><strong>以属性为要素，以价值为连接，以交易为目的</strong></font>，属性又可分为有形属性与无形属性，二者之间有时候并不是割裂的，价值是能满足人们的某些需求，是物品与货币之间的连接关系，交易是产品生产的目的。</p>
<p>然而这些都是教科书式的 定义，对产品的认知到这一层次已经可以超越绝大部分人，但它也只是停留在”产品“层次，而不是“作品”，更不是“艺术品”。</p>
<p>在我看来 产品 还是具有灵魂的，产品是由人创造的，其自然会带有人的思想、人的创造、人的理念在里头，宗师与学徒画同样的一幅画，虽然东西都一样但是那个味道往往是不一样的。因此，要理解一款产品还需要理解其背后的人的设计理念，在此，我给产品注入人的灵魂，即“理念”，从而进一步扩展产品的第一性原理：</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">产品 = 属性 + 价值 + 交易 + 理念<br></code></pre></td></tr></table></figure>
<p>开源软件是信息的载体，其表现形式是具有无形的信息属性，是作为计算机程序的形式而存在的，要将开源软件产品化就需要将开源软件的属性价值化、可交易化以及注入人的设计理念。</p>
<h2 id="如何将一个软件产品化"><a href="#如何将一个软件产品化" class="headerlink" title="如何将一个软件产品化"></a><font color="#FF8C00">如何将一个软件产品化</font></h2><h3 id="价值与交付"><a href="#价值与交付" class="headerlink" title="价值与交付"></a><font color="#00CED1">价值与交付</font></h3><p>如何将一个软件产品化回答的是<strong>“How”</strong> 的问题，在此之前还应该搞明白<strong>“Why”</strong>的问题，一个软件产品或者其特性为什么需要做也有一套方法论，这里我称之为 <font color="#E01000"><strong>“产品交付之双轮驱动模型”</strong></font>（如下图）：</p>
<p><img src="https://wuchangping.oss-cn-hangzhou.aliyuncs.com/product/product-value-and-delivery.PNG" alt="价值与交付"></p>
<p>在这个双轮驱动思维模型里有以下几个原则：</p>
<ul>
<li>以客户价值为前轮，前轮把握方向，解决的是需求探索、价值确定、特性探讨以及价值精炼的过程。首先是以客户价值为导向输入客户需求、但是这个需求还需要去伪存真、去粗纯精、过滤提炼，才能作为产品交付轮的输入，而不是只要是客户需求，不管是真需求还是假需求、也不管是有价值的、还是无价值的都全部输出到产品交付轮，无效的消耗产品交付资源；</li>
<li>以产品交付为后轮，后轮提供驱动力，解决的是开发、测试、运维以及获取客户反馈，再根据这个客户反馈的结果作为开发的输入的过程。在产品交付轮中很重要的一环是<strong>“反馈“</strong>，其角色是作为客户与交付之间的桥梁，开发需要依据”客户反馈”作为输入，而不是自个闭门造车；</li>
<li><p>客户价值又可分为主动式客户价值与被动式客户价值，获取客户需求的方式也需要合理取舍：</p>
<ul>
<li>主动式客户价值：有些客户”久病成医“，非常清楚自个痛点、难点、挑战点在哪里，也非常清楚自个需要什么样的解决方案可以药到病除，从而可以精确的输出自我的需求。这种客户对产品交付来说可遇而不可得，成本最低，需求最精确；</li>
<li>被动式客户价值：这种情况下，光是在那里等待，从而期望客户能给出明确的需求作为输入，那是缘木求鱼、刻舟求剑，效率也非常低下。如同医院里的医生给病人看病一样，绝大多数客户其实只能知道表征，而不知道根因，因此就需要由产品交付轮以客户专家的角色提出解决方案，作为客户价值需求输入给客户，再看客户的使用效果得出反馈，再依据这个反馈调整解决方案。</li>
</ul>
</li>
<li><p>在双轮驱动模型里，二者谁都离不开谁，不是厚此薄彼的关系，而是二者互相协作从而推动产品往商业成功这个目标前进的关系；</p>
</li>
<li><p>先有买家需求再有产品交付，而不是先有产品交付再找买家需求，需要明晰这个先后关系，为客户找出差异化需求才是产品交付的本质，寻求差异化、避免同质化，才是真正的以客户为中心。</p>
</li>
</ul>
<p>因此，在将一个技术产品化之前，先花几分钟时间问问其价值在哪里，为什么需要做这个，这一点很重要，要能区分客户要的是能马上就能解决痛点的止痛片还是可有可无的无关紧要的维生素，从而以此进行任务排序，明晰产品交付与客户价值的双轮驱动关系，要能清楚的理解<font color="#00CED1"><strong>“以客户为中心”</strong></font>的价值理念以及让产品的获得<font color="#00CED1"><strong>“商业成功”</strong></font>的终极目标。</p>
<h3 id="技术产品化"><a href="#技术产品化" class="headerlink" title="技术产品化"></a><font color="#00CED1">技术产品化</font></h3><p>通常来讲开源软件的产品化可以从价值、交易以及理念这三个方面进行。价值：可服务化、无形化有形、价值竞争，交易：可度量化、个性标准化，以及融入人的设计理念：复杂简单化等。</p>
<h4 id="可服务化"><a href="#可服务化" class="headerlink" title="可服务化"></a><font color="#E01000">可服务化</font></h4><p>可服务化指的是从技术实现上支持可服务化，ToB产品常常是半产品半服务的，而且一般会签约服务质量保证协议SLA，因此除了团队需要有替客户解决问题的能力外，还需要从技术与流程上支持可服务化，其中包括：</p>
<ul>
<li>可运维性：易用的部署（步骤量化）、升级（AB测试、in-place、replace、rolling-back等）、数据迁移、自动化运维支持等。在一个产品的全生命周期里，开发也许只占20%不到的时间，而将近80%的时间都需要运维，因此需要拿出近4倍比的开发重视程度，重视可运维的设计与实现；</li>
<li>可观测性：可观测性主要分为四大类: 监控、告警、日志、追踪；</li>
<li>可操作性：支持远程接入、开放服务接口、后台管理UI、CLI、特性参数配置开关；</li>
<li>健康管理：健康检查支持、健康报告支持、自动提交故障问题单支持；</li>
<li>安全性：安全性是企业级产品必备，数据保护、密码安全、连接检查、LIB库授权协议等；</li>
<li>多租户：多租户可以支持多团队、多部门小规模部署，进行业务隔离，也是非常重要的企业级特性；</li>
<li>可视化：提供易用的用户UI、CLI;</li>
<li>可支持：如何指定进行客户支持规则？如何升级成工程师团队介入提供服务定位问题或者排除问题？</li>
</ul>
<p>当看到以上类目，脑海里就能闪现出需要怎么去实现这些以及用什么组件可以最佳实践的快速完成交付，而不是停留在概念的阶段，那才算对可服务化有了自己的理解。</p>
<h4 id="无形化有形"><a href="#无形化有形" class="headerlink" title=" 无形化有形"></a><font color="#E01000"> 无形化有形</font></h4><p>无形化有形指的是将无形的软件硬件化或者云化，单单一个软件包是难以让用户买单的，需要把它硬件化，打包到服务器里以有形产品的形态销售出去，或者云化后以服务的无形形态销售出去。</p>
<h4 id="价值竞争"><a href="#价值竞争" class="headerlink" title=" 价值竞争"></a><font color="#E01000"> 价值竞争</font></h4><p>价值竞争指的是<strong>“参与到客户的购买周期中，在每个阶段为客户创造价值”</strong>[3]，从单纯的销售产品到提供整套生态化的解决方案。单纯的依靠销售产品往往已经难以给客户提供差异化的价值，并且也会面临低利润的同质化竞争，那么这个时候就需要更进一步的提供生态化的解决方案，针对行业需求做端到端的全生态化的解决方案。</p>
<p>生态化的解决方案化能给客户提供差异化的价值关系。比如，一份药品在药店里只能卖30块，而且只是一次销售无法挖掘后续价值。但是到了医院就不一样了，其依据客户的”恐惧“为刚需的基石，提供一整套的类生态化的医疗解决方案，从挂号预约、望闻问切、到各种仪器设备过一遍、再到开出药方、再依据客户的反应效果把这个过程再来几遍，因此在药店里30块钱的药，在医院里就能卖到 300块、3000块，获取十倍、百倍、千倍利润。</p>
<font color="#E01000"><strong>PS: 做生意要走正道，有良心的医院“以客户为中心”药到病除，无良医院“以利润为中心”无尽压榨客户，祝早日倒闭。</strong></font>

<h4 id="可度量化"><a href="#可度量化" class="headerlink" title="可度量化"></a><font color="#E01000">可度量化</font></h4><p>可度量化指的是质量要可以量化，可预测的业务指标（比如AI训练里的精度、加速比、收敛时间、训练次数等）、性能、可靠性、可用性、可伸缩性、稳定性、容错性、可测试性等，这些很抽象的指标要能量化。在产品功能同质化的场景下，质量是最重要的差异化竞争力。</p>
<p>业务性能、可靠性、可用性、可伸缩性这几者之间页互相制约，质量与成本、时间也互相制约，同时在云化的场景下客户又有SLA要求，不满足SLA要求的服务，除了要赔钱，还严重影响商业信誉，因此质量指标之间也需要合理取舍。</p>
<h4 id="个性标准化"><a href="#个性标准化" class="headerlink" title=" 个性标准化"></a><font color="#E01000"> 个性标准化</font></h4><p>个性标准化指的是将个性化的、“DIY”化的开源项目转成标准化的、可复制的、可量化的，同时依据资源的规格约束进行标准化，比如依据服务器规格、虚机规格，机架规格等进行标准化，例如AI服务器的配置就需要定义CPU、内存、磁盘、带宽以及训练卡的标准的规格，这样才能提供可预测的性能、可预测的加速比等质量指标，再比如云端场景下的服务监控，除了定义指标的名称之外，还需要定义监控指标的类型、故障码、输出的标记以及对应的处理措施等，所有的这些都要能标准化、可操作性化。</p>
<h4 id="复杂简单化"><a href="#复杂简单化" class="headerlink" title=" 复杂简单化"></a><font color="#E01000"> 复杂简单化</font></h4><p>复杂简单化指的是把复杂的体验简单化， 抽象及简化API、量化的安装步骤、高内聚低耦合的设计、易用的UI等，这里又涉及到产品设计哲学、人类的心理学等，也跟人的设计理念相关。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><font color="#FF8C00">小结</font></h2><p>本文以方法论的形式解读了软件开发过程当中经常会遇到的两个问题：”什么是产品以及如何将一个开源的软件项目产品化“，讲的是“无用”的知识。</p>
<p>日拱一卒，功不唐捐，分享是最好的学习，与其跟随不如创新，希望这个知识点对大家有用，另作者能力与认知都有限，”我讲的，可能都是错的“，欢迎大家拍砖留念。</p>
<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a><font color="#FF8C00">作者简介</font></h2><p>常平，中科大硕，某AI独角兽深度学习首席软件工程师，前EMC 大数据资深首席工程师，主要工作背景在深度学习、流式大数据、云计算、分布式中间件以及Linux内核。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><font color="#FF8C00">参考资料</font></h2><p>[1] <a href="https://a16z.com/2019/10/04/commercializing-open-source/" target="_blank" rel="noopener">https://a16z.com/2019/10/04/commercializing-open-source/</a></p>
<p>[2] <a href="https://baike.baidu.com/item/%E4%BA%A7%E5%93%81/105875" target="_blank" rel="noopener">https://baike.baidu.com/item/%E4%BA%A7%E5%93%81/105875</a></p>
<p>[3] 《价值竞争：以客户为中心的销售转型》 - 付遥</p>
<h2 id="版权申明"><a href="#版权申明" class="headerlink" title="版权申明"></a><font color="#FF8C00">版权申明</font></h2><p>本文的版权协议为 CC-BY-NC-ND license：<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh</a></p>
<p>在遵循署名、非商业使用（以获利为准）以及禁止演绎的前提下可以自由阅读、分享、转发、复制、分发等。</p>

      
    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/product/" rel="tag"><i class="fas fa-tags"></i>product</a>
        
      </div>
      
    </footer>
  </article>
  
  <article class="article post card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="www.changping.me/2020/04/10/distributed-theory-cap-pacelc/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="常平">
        <meta itemprop="description" content="“分布式系统架构设计师”">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="常平的技术博客">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2020/04/10/distributed-theory-cap-pacelc/" itemprop="url">分布式系统架构设计 – 第21式 - 基础理论 - 从CAP到PACELC</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2020-04-10T21:30:38+08:00">2020-04-10 21:30:38</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/distributed/" itemprop="url" rel="index"><span itemprop="name">distributed</span></a></span>
        </span>
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><font color="#FF8C00">前言</font></h2><p>分布式系统是一门讲究实践的软件工程，只有PK过设计方案，从微观处手把手的敲过一行行的代码，才能知道细节在哪里，难点在哪里，痛点、挑战点在哪里。同时，分布式系统也是一门讲究理论的软件工程，从宏观处着眼深刻理解系统设计的理论，将理论与实践相结合，想好、做好、说好才是真的好。因此，宏观处着眼，微观处着手，才能真正掌握分布式系统。自此，本系列文章开始讲诉分布式系统设计里的基础理论，本文为CAP与PACELC理论。</p>
<h2 id="CAP理论与PACELC理论"><a href="#CAP理论与PACELC理论" class="headerlink" title=" CAP理论与PACELC理论"></a><font color="#FF8C00"> CAP理论与PACELC理论</font></h2><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title=" CAP理论"></a><font color="#00CED1"> CAP理论</font></h3><p>CAP理论是分布式系统最为基本的指导理论之一，是分布式系统设计时最为基本的取舍依据，CAP理论认为一致性、可用性、分区容忍性不能同时满足，即：</p>
<ul>
<li><p>一致性(Consistency): 所有的节点在同一时刻看到同样的数据；</p>
</li>
<li><p>可用性(Availability):  节点失效不会影响系统的读写；</p>
</li>
<li><p>分区容忍性(Partition Tolerance): 系统能支持网络分区，即使分区之间的消息丢失系统也正常工作。</p>
</li>
</ul>
<p>但是，CAP理论也有其自身的局限性。在工程实践中CAP理论的应用可以一分为二：系统整体以及系统内部。比如，系统整体可以选择CA或者CP，但是系统内部微观处有些特性却可以同时满足CAP三要素，因为分区是件极少发生的事，为了追求卓越的设计理念可以尽量同时满足CAP三要素。根据业务场景的不同，不同的分布式系统会根据自身业务的需求在CAP三者中进行取舍， CAP理论的意义是一种在分布式系统设计时取舍的参考因素，而非绝对的三者必舍其一。</p>
<p>此外，在CAP理论中是没有提到系统的时延（Latency）的，而访问时延（Latency）却是很重要的可用性(Availability)因素，因此又延申出了PACELC理论。</p>
<h3 id="PACELC理论"><a href="#PACELC理论" class="headerlink" title="PACELC理论"></a><font color="#00CED1">PACELC理论</font></h3><p>PACELC理论是CAP理论的扩展，PACELC理论在wiki上的定义是:</p>
<blockquote>
<p>It states that in case of network partitioning (P) in a distributed computer system, one has to choose between availability (A) and consistency (C) (as per the CAP theorem), but else (E), even when the system is running normally in the absence of partitions, one has to choose between latency (L) and consistency (C).</p>
</blockquote>
<p>意思就是：</p>
<blockquote>
<p>如果有分区partition (P)，系统就必须在availability 和consistency (A and C)之间取得平衡; 否则else (E) 当系统运行在无分区情况下,系统需要在 latency (L) 和 consistency (C)之间取得平衡</p>
</blockquote>
<p>如下图，在PACELC里添加了Latency要素：</p>
<p><img src="https://wuchangping.oss-cn-hangzhou.aliyuncs.com/distributed/theory/distributed-cap-pacelc-1.PNG" alt="cap-pacelc"></p>
<p>当前分布式系统设计指导理论应当采用PACELC理论替代CAP理论，理由如下：</p>
<ul>
<li><p>PACELC更能满足实际操作中分布式系统的工作场景是更好的工程实现策略；</p>
</li>
<li><p>当partition (P)存在的场景下，需要在availability 和consistency (A and C)之间取舍，但是实际上分布式系统中绝大多数时间里partition (P)是不存在的，那么就需要在latency (L) 和 consistency (C)之间作取舍；</p>
</li>
<li><p>Availability在不存在partition (P)的场景下跟 latency关联,在partition (P)时跟”可靠性“指标相关联；</p>
</li>
<li><p>PACELC 可以在 latency 与 consistency之间获得平衡；</p>
</li>
<li><p>CAP 理论忽略了 一致性和时延之间的取舍；</p>
</li>
</ul>
<p>PACELC理论是建立在CAP理论之上的，二者都描述了一致性(Consistency)、可用性(Availability)和分区容忍性(Partition Tolerance)之间的约束与取舍。而PACELC理论则更进一步描述了即使在没有Partition的场景下，也存在Latency和Consistency之间的取舍，从而为分布式系统的Consistency模型提供了一个更为完整的理论依据。</p>
<h3 id="理论应用"><a href="#理论应用" class="headerlink" title="理论应用"></a><font color="#00CED1">理论应用</font></h3><p>要保证系统数据的高可用（high availability）那么有个技术方案是采用数据冗余备份的方式，那么就涉及到复制数据，而进行分布式系统的数据复制，就会出现在Consistency和Latency之间做个取舍的要求。举个例子，如下图所示：</p>
<p><img src="https://wuchangping.oss-cn-hangzhou.aliyuncs.com/distributed/theory/distributed-cap-pacelc-2.PNG" alt="consistency-latency"></p>
<p>在强一致性复制场景下，需要三副本都下盘才能返回OK确认信息给client端，假设Master节点向 Slave 节点复制数据，时延的限制是 20ms，有时候，slave 2 硬盘或网络出现故障，Master 往 Slave 复制数据的时延超过 了20ms，这个时候如果还一直等待 slave 2 返回结果再通知给client就会出现性能和时延抖动，而且这种抖动是经常会发生的长尾效应。</p>
<p>依据PACELC理论，我们可以在 consistency和Latency之间做个取舍，比如 slave 2 节点的时延超过 20ms了，就不等待slave 2 返回，master 和 slave 1 返回结果给client即可，如果 slave 2 出现 超时的 次数超过 5次那么就认为 这个节点可能出现故障，打个故障标签，进行后续的处理。采用这种方式可以消除写时的长尾抖动，获得更优雅的写时性能曲线。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><font color="#FF8C00">小结</font></h2><p>本文遵循理论与实践相结合的指导思想讲述了CAP理论与PACELC理论。日拱一卒，功不唐捐，分享是最好的学习，与其跟随不如创新，希望这个知识点对大家有用。另作者能力与认知都有限，”我讲的，可能都是错的“，欢迎大家拍砖留念。</p>
<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a><font color="#FF8C00">作者简介</font></h2><p>常平，中国科学技术大学硕士研究生，深度学习首席软件主管工程师，前EMC 大数据资深首席工程师，主要从事Linux内核以及分布式产品的架构设计、开发以及交付工作。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><font color="#FF8C00">参考文献</font></h2><p>[1] <a href="https://en.wikipedia.org/wiki/PACELC_theorem" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/PACELC_theorem</a></p>
<p>[2] CAP理论与分布式系统设计，S先生</p>
<h2 id="版权申明"><a href="#版权申明" class="headerlink" title="版权申明"></a><font color="#FF8C00">版权申明</font></h2><p>本文的版权协议为 CC-BY-NC-ND license：<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh</a></p>
<p>在遵循署名、非商业使用（以获利为准）以及禁止演绎的前提下可以自由阅读、分享、转发、复制、分发等。</p>

      
    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/distributed/" rel="tag"><i class="fas fa-tags"></i>distributed</a>
        
      </div>
      
    </footer>
  </article>
  
  <article class="article post card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="www.changping.me/2020/03/15/distributed-ideamodel-programing/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="常平">
        <meta itemprop="description" content="“分布式系统架构设计师”">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="常平的技术博客">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2020/03/15/distributed-ideamodel-programing/" itemprop="url">分布式系统架构设计 – 第20式 - 编程思维模型</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2020-03-15T20:28:20+08:00">2020-03-15 20:28:20</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/distributed/" itemprop="url" rel="index"><span itemprop="name">distributed</span></a></span>
        </span>
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><font color="#FF8C00">前言</font></h2><p>编程是一种创造性解决问题的能力， 其本质上是一种思维体操，可以大大的提升人的逻辑能力、推理能力以及解决问题的能力， 那么什么是分布式系统的编程思维呢？</p>
<h2 id="编程思维模型"><a href="#编程思维模型" class="headerlink" title="编程思维模型"></a><font color="#FF8C00">编程思维模型</font></h2><p>具体来看分布式系统的编程思维包含11大内容：</p>
<blockquote>
<p>抽象、分层、解耦、拆分、聚合、治理、取舍、模型、演化、质量、边界。</p>
</blockquote>
<font color="#FF8C00">这个主题的解读，留待以后完善了再补充</font>

<p>//TODO</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><font color="#FF8C00">小结</font></h2><p>本文解读了分布式系统的编程思维模型。日拱一卒，功不唐捐，分享是最好的学习，与其跟随不如创新，希望这个知识点对大家有用。另作者能力与认知都有限，”我讲的，可能都是错的“，欢迎大家拍砖留念。</p>
<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a><font color="#FF8C00">作者简介</font></h2><p>常平，中科大硕，DELL EMC 资深首席工程师，曾就职于Marvell、AMD，主要从事Linux内核以及分布式产品的交付、架构设计以及开发工作。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><font color="#FF8C00">参考资料</font></h2><p>[1] </p>
<h2 id="版权申明"><a href="#版权申明" class="headerlink" title="版权申明"></a><font color="#FF8C00">版权申明</font></h2><p>本文的版权协议为 CC-BY-NC-ND license：<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh</a></p>
<p>在遵循署名、非商业使用（以获利为准）以及禁止演绎的前提下可以自由阅读、分享、转发、复制、分发等。</p>

      
    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/distributed/" rel="tag"><i class="fas fa-tags"></i>distributed</a>
        
      </div>
      
    </footer>
  </article>
  
  <article class="article post card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="www.changping.me/2020/03/14/distributed-ideamodel-distributedsystem/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="常平">
        <meta itemprop="description" content="“分布式系统架构设计师”">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="常平的技术博客">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2020/03/14/distributed-ideamodel-distributedsystem/" itemprop="url">分布式系统架构设计 – 第19式 - 分布式系统八卦思维模型</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2020-03-14T20:08:20+08:00">2020-03-14 20:08:20</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/distributed/" itemprop="url" rel="index"><span itemprop="name">distributed</span></a></span>
        </span>
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><font color="#FF8C00">前言</font></h2><p>懂得很多道理，仍旧过不好这一生。懂得很多分布式系统的概念以及设计方法，依旧做不好分布式系统。分布式系统设计是一门实践软件工程，只有你PK过设计方案，手把手的敲过一行行的代码，才能知道细节在哪里，难点在哪里，痛点、挑战点在哪里，不是看书或者看文章就可以完全掌握的。因此，宏观处着眼，微观处着手，才能完全掌握分布式系统设计的道理。本文抽象出分布式系统的思维模型，当你看到这个模型里的字眼与图画，就可以从脑海里分解出一个个设计方案、一行行代码的时候，那才是真的掌握了分布式系统的精髓。</p>
<h2 id="分布式系统八卦思维模型"><a href="#分布式系统八卦思维模型" class="headerlink" title="分布式系统八卦思维模型"></a><font color="#FF8C00">分布式系统八卦思维模型</font></h2><p>这里我提出一个分布式系统八卦思维模型，如下图，其要义如下：</p>
<p><img src="https://wuchangping.oss-cn-hangzhou.aliyuncs.com/distributed/ideamodel/idea-model-distributed-system.PNG" alt="分布式系统思维模型"></p>
<h3 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a><font color="#00CED1">方法论</font></h3><p>核心：在前面的文章里讲到可以用一句话来描述分布式系统：</p>
<blockquote>
<p>分布式系统是指其组件位于不同的网络计算机上的系统，这些组件通过相互传递消息来进行通信和协调其动作，且彼此相互交互以完成一个共同的任务目标。</p>
</blockquote>
<p>并且提到了“系统 = 要素 + 连接 + 目标”  ， 这个思维模型的核心即分布式系统的第一性原理， 公式：“分布式系统 = 计算机 + 网络 + 协同”，要素是计算机（新的虚机、容器也算），连接是网络，目标是协同以完成共同任务。</p>
<p>提供：即服务接入的提供，指的是对外提供restful 接口服务：权限、多组合、监控、审计、计费等，对外提供SQL服务接入接口服务、对外提供自然语言接入接口服务等<br>注册：即服务注册，将集群的工作负载注册到集群注册中心<br>配置：即配置管理，将集群的配置管理在配置中心；<br>调用，即服务调用，各种RPC调用，系统内的消息传递<br>路由：即服务路由，目的是集群的负载均衡与扩伸缩性<br>观测：指的是集群内部指标的可观测性，即监控、告警、追踪、日志<br>治理：指的是集群内部的服务治理：熔断、降级、限流、隔离、容错<br>编排：即服务编排，基于k8s+ docker，完成安装、升级、扩容、运维、调度等；<br>质量：指的是安装部署运维质量、客户质量、用户质量与开发质量<br>边界：指的是系统内的约束条件，涵盖 硬件资源、客户约束、用户约束以及团队约束</p>
<p>这10个功能与核心之间是互相联系、互联影响的，因此类似于一个八卦图。</p>
<h3 id="底层思维"><a href="#底层思维" class="headerlink" title="底层思维"></a><font color="#00CED1">底层思维</font></h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">抽象、分层、解耦、拆分、聚合、治理、取舍、质量、边界、模型、演化<br></code></pre></td></tr></table></figure>
<p>抽象、分层、解耦、拆分、聚合、治理、取舍、质量、边界、模型、演化是分布式系统设计的底层思维，也是软件工程的底层思维，这个主题很难掌握，目前，这里不展开讲。</p>
<h3 id="基石假设"><a href="#基石假设" class="headerlink" title="基石假设"></a><font color="#00CED1">基石假设</font></h3><p>分布式系统有两个隐含的基石假设，即 “资源协同与质量可预测”，资源即计算机、虚拟机、容器以及网络，基于此，分布式系统的第一性原理 即： “分布式系统 = 计算机 + 网络 + 协同 ，以质量为度量”。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><font color="#FF8C00">小结</font></h2><p>本文提出一个分布式系统八卦思维模型。分布式系统不是我首创，用这个类八卦图形来表示思维模型也不是我首创，但是用这个类八卦图形表示分布式系统思维模型应该是我首创，目前不管是书籍还是网络都找不到这样的分布式系统思维模型。日拱一卒，功不唐捐，分享是最好的学习，与其跟随不如创新，希望这个知识点对大家有用。另作者能力与认知都有限，”我讲的，可能都是错的“，欢迎大家拍砖留念。</p>
<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a><font color="#FF8C00">作者简介</font></h2><p>常平，中科大硕，DELL EMC 资深首席工程师，曾就职于Marvell、AMD，主要从事Linux内核以及分布式产品的交付、架构设计以及开发工作。</p>
<h2 id="版权申明"><a href="#版权申明" class="headerlink" title="版权申明"></a><font color="#FF8C00">版权申明</font></h2><p>本文的版权协议为 CC-BY-NC-ND license：<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh</a></p>
<p>在遵循署名、非商业使用（以获利为准）以及禁止演绎的前提下可以自由阅读、分享、转发、复制、分发等。</p>

      
    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/distributed/" rel="tag"><i class="fas fa-tags"></i>distributed</a>
        
      </div>
      
    </footer>
  </article>
  
  <article class="article post card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="www.changping.me/2020/02/24/distributed-theory-of-essence/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="常平">
        <meta itemprop="description" content="“分布式系统架构设计师”">
        <meta itemprop="image" content="/images/avatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="常平的技术博客">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2020/02/24/distributed-theory-of-essence/" itemprop="url">分布式系统架构设计 – 第18式 - 以物理学思维破解分布式系统的本质</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2020-02-24T22:23:38+08:00">2020-02-24 22:23:38</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/distributed/" itemprop="url" rel="index"><span itemprop="name">distributed</span></a></span>
        </span>
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><font color="#FF8C00">前言</font></h2><p>本文的动机在于应用物理学思维模型破解分布式系统背后不变的本质，并以此解读分布式系统里的各种算法设计、功能设计以及非功能设计。在“分布式系统” 这个词语里，关键词可以分为“分布式”及“系统”，而<strong>“系统 = 要素 + 连接 + 目标”</strong>，在这个公式里，要素的变化不会影响系统的本质，而“连接或目标”的变化就会改变系统的本质，其中“分布式”是系统的连接方式，挖掘分布式系统背后的本质即是挖掘“分布式系统”的要素、连接以及目标的本质。</p>
<p>物理学的价值观在于追求所有物理现象背后的共同的底层规律，并以此解读各种物理现象，并且其具有“可解释、可重复、可预测”的可度量性，这种共同的底层规律，被称之为元认知，即第一性原理：“任何变化的背后都有不变的本质”。将这种思维模型应用于挖掘分布式系统的本质，需要解决两个问题，即：“ 什么是分布式系统的第一性原理？以及如何度量分布式系统？”</p>
<h2 id="分布式系统的价值与目的"><a href="#分布式系统的价值与目的" class="headerlink" title="分布式系统的价值与目的"></a><font color="#FF8C00">分布式系统的价值与目的</font></h2><p>分布式系统的出现是为了解决一个主要矛盾，即：“日益增长的数据计算、传输与存储的需求与当前单点计算机能力无法满足这个需求之间的矛盾”。分布式系统可以通过伸展集群规模解决这个矛盾，因此这就是分布式系统的价值，而可伸缩性(Scalability，避免与可扩展性extensibility混淆)也是分布式系统的根本目的。</p>
<h2 id="分布式系统必知的基础理论与算法"><a href="#分布式系统必知的基础理论与算法" class="headerlink" title="分布式系统必知的基础理论与算法"></a><font color="#FF8C00">分布式系统必知的基础理论与算法</font></h2><p>分布式系统必须理解、必须会的基础理论算法有：CAP/PACELC、BASE、2PC、3PC、TCC、ACID、PAXOS、RAFT这9个：</p>
<ul>
<li>CAP: CAP理论认为以下三者不能同时满足：<ul>
<li>一致性(Consistency): 所有的节点在同一时刻数据是完全一样的；</li>
<li>可用性(Availability): 节点失效不会影响系统的IO；</li>
<li>分区容忍性(Partition Tolerance): 系统能支持网络分区（网络连接故障），即使分区之间的消息丢失系统也正常工作。</li>
</ul>
</li>
<li>PACELC: PACELC理论是CAP理论的扩展，如果有分区partition (P)，系统就必须在availability 和consistency (A and C)之间取得平衡; 否则else (E) 当系统运行在无分区情况下,系统需要在 latency (L) 和 consistency (C)之间取得平衡”；</li>
<li>BASE: BASE是基本可用（Basically Available）、软状态（Soft state）和最终一致性（Eventually consistent）三个短语的缩写；</li>
<li>2PC：two-phase commit protocol，两阶段提交；</li>
<li>3PC: three-phase commit protocol ，三阶段提交，其在两阶段提交的基础上增加了CanCommit阶段，并引入了超时机制；</li>
<li>TCC: Try-Confirm-Cancel，又称补偿事务，其核心思想是：”针对每个操作都要注册一个与其对应的确认和补偿（撤销操作）”；</li>
<li>ACID: 原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durablity）；</li>
<li>PAXOS/RAFT ：PAXOS与RAFT算法都是最有效的解决分布式一致性问题的算法。</li>
</ul>
<p>这几条基础理论与算法需要自己深入学习理解，其是分布式系统的必备知识点。</p>
<h2 id="分布式系统的功能与非功能"><a href="#分布式系统的功能与非功能" class="headerlink" title="分布式系统的功能与非功能"></a><font color="#FF8C00">分布式系统的功能与非功能</font></h2><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>功能可按职责划分为服务功能与算法功能:</p>
<ul>
<li>分布式系统里的最主要的服务功能有：服务提供，服务注册，服务配置，服务调用、服务路由、服务治理设计，服务观测、服务安全这8项；</li>
<li>分布式系统里的最主要的算法功能有：幂等性设计、事务算法设计、端到端的校验算法设计、路由算法设计、分区分配算法设计、集群视图变更算法设计、心跳算法设计、注册算法设计、复制一致性算法设计以及容量规划算法设计。</li>
</ul>
<h4 id="非功能"><a href="#非功能" class="headerlink" title="非功能"></a>非功能</h4><p>非功能可划分为质量与约束：</p>
<ul>
<li><p>质量是分布式系统在约束条件下的度量方式，其涵盖：合适的性能（Performant）、可用性(Availability)、可靠性(Reliability)、可伸缩性(Scalability)、韧性(resilience)、可观测性(Observability)、安全性（security）、易用性（usability）、可运维性（operability）、可测试性(testability)、可维护性(maintainability)、可扩展性(extensibility)、可读性(readability)等。</p>
</li>
<li><p>约束是分布式系统的资源限制：网络物理容量与计算机节点的物理容量，以及客户、用户、团队的边界约束。</p>
</li>
</ul>
<p><strong>分布式系统交付的目的是功能的价值，但是产品的功夫却体现在非功能</strong>，分布式系统的质量是分布式系统的度量方式，分布式系统要可度量就需要具有“可解释、可复制、可预测”的质量保证。</p>
<h2 id="分布式系统的第一性原理"><a href="#分布式系统的第一性原理" class="headerlink" title="分布式系统的第一性原理"></a><font color="#FF8C00">分布式系统的第一性原理</font></h2><p>依据李善友老师的定义： <font color="#00CED1"><strong>“第一性原理思维 = 逻辑奇点 + 公理化方法 ”</strong></font>，逻辑奇点即基石假设，公理化方法我认为是”定公理、推定理、再公式化应用”。因此欲找出分布式系统的第一性原理，就需要先挖掘出分布式系统的公理化定义及其逻辑奇点。</p>
<p>首先把分布式系统概念化，Google 出来的对分布式系统的定义有：</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">A distributed system is a system whose components are located on different networked<br>computers, which communicate and coordinate their actions by passing messages to one<br>another. The components interact with one another in order to achieve a common goal.<br></code></pre></td></tr></table></figure>
<p>即：</p>
<blockquote>
<p>分布式系统是指其组件位于不同的网络计算机上的系统，这些组件通过相互传递消息来进行通信和协调其动作，且彼此相互交互以完成一个共同的任务目标。</p>
</blockquote>
<p>拆解这句话，从中可以看到分布式系统里的要素即为组件，连接即网络，目标是共同的任务，并且还可以看出4个要点：</p>
<ul>
<li><p>分布式系统的组件是位于不同的网络计算机上；</p>
</li>
<li><p>分布式系统的组件通过传递消息进行通信其动作；</p>
</li>
<li><p>分布式系统的组件通过传递消息进行协调其动作；</p>
</li>
<li><p>分布式系统的组件是通过相互交互以完成一个共同的任务目标；</p>
</li>
</ul>
<p>其中最最重要的可以看作是分布式系统的基石假设的要点是：</p>
<p>1，分布式系统的组件是位于不同的网络计算机上；</p>
<p>2，这些组件通过相互传递消息来进行通信和协调其动作，且彼此相互交互以完成一个共同的任务目标。</p>
<p>这两点即为分布式系统的逻辑奇点，破除了这两点那就不是分布式系统，比如去掉网络计算机的定义，那就是单机系统，去掉协调以完成共同的任务目标，那就只是一个计算机网络。这两点基石假设构成分布式系统的逻辑奇点。</p>
<p>到此，可以得出分布式系统的公理化定义：</p>
<blockquote>
<p>分布式系统是指其组件位于不同的网络计算机上的系统，这些组件通过相互传递消息来进行通信和协调其动作，且彼此相互交互以完成一个共同的任务目标。</p>
</blockquote>
<p>以及分布式系统的逻辑起点：</p>
<blockquote>
<ul>
<li><p>分布式系统是指其组件位于不同的网络计算机上的系统：即计算机网络；</p>
</li>
<li><p>这些组件通过相互传递消息来进行通信和协调其动作，且彼此相互交互以完成一个共同的任务目标：即协同：“谐调一致，和合共同，协调两个或者两个以上的不同资源或者个体，一致地完成某一共同目标”；</p>
</li>
</ul>
</blockquote>
<p>再进一步抽象，可以推断出“分布式系统就是通过计算机网络进行协同工作的系统”， 至此，可以推出分布式的公理化定义公式：</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">分布式系统 = 计算机 + 网络 + 协同，其以质量为度量。<br></code></pre></td></tr></table></figure>
<p>这个公式就是分布式的第一性原理公式，是分布式的本质理论定义，其中“计算机”是分布式系统的要素，“网络”是分布式系统的连接，“协同”是分布式系统的目标，从这公式里可以看出分布式系统的3个原生的难题：</p>
<ul>
<li><p>分布式系统是基于网络的系统，那么网络自身所具有的所有的优点与缺点它都有，那么如何提高服务的可靠性？如何保证服务的可用性？如何保证网络可运维？</p>
</li>
<li><p>分布式系统是基于消息传递的系统，消息传递是不可靠的，那么如何保证消息的正确性？如何保证消息传递的可靠性？如何传递消息到目的地？如何保证消息传递的负载均衡？</p>
</li>
<li><p>分布式系统是协同工作的系统，那么如何协调大量的计算机节点的完成一个共同的目标，如何解决协调的复杂性以及提高协调的可靠性、可用性？那么如何一起交互完成一个共同的目标任务？如何拆分目标？如何聚合目标，如何度量完成任务的质量与边界？</p>
</li>
</ul>
<p>因此还需要依据分布式系统的公理化定义推导出定理化定义。</p>
<h2 id="分布式系统的定理化推导"><a href="#分布式系统的定理化推导" class="headerlink" title="分布式系统的定理化推导"></a><font color="#FF8C00">分布式系统的定理化推导</font></h2><p>“公理是不证自明的，而定理是以若干的公理或其他定理为基础而推导的”。由公理推定理，从分布式的公理化公式<font color="#00CED1"><strong>“分布式系统 =  计算机  + 网络 + 协同”</strong></font>，可知分布式系统是组件位于“不同的计算机网络”上一起“协同”工作的系统，这句话得出分布式系统三要素：<font color="#00CED1">“计算机、网络，协同”</font>。其中计算机是系统要素，改变计算机为虚机或者容器，不会改变分布式系统的本质。网络是系统的连接，改变连接就会改变系统的本质，当连接一台计算机时，就是单机，当连接两台计算机时就是镜像，当连接 多于两台计算机时就是分布式。协同是系统的目标，当改变协同的目标也就改变了系统的功能，比如共同计算与共同存储、共同调度，其功能目标是不一样的。</p>
<h3 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h3><p>分布式系统是基于不同的计算机上的系统，计算机也是分布式系统的要素之一，因此分布式系统也继承了计算机的原生缺点，</p>
<ul>
<li>计算机节点是会出故障的，主板、CPU、网卡、硬盘、内存、电源等都会出故障，比如老化、失效等；</li>
<li>计算机节点内的操作系统是会突然奔溃不能提供服务的；</li>
<li>计算机节点是会突然掉电的；</li>
<li>计算机节点里的内存下电是不保数据的；</li>
<li>计算机节点的资源是有限的：CPU是有算力上限的、内存是有大小限制的、网卡有吞吐量限制、硬盘有空间大小限制以及速率限制；</li>
</ul>
<p>这几个计算机的原生缺点意味着分布式系统需要能够知道计算机节点是失效的，以及在计算机节点失效的同时保证服务质量设计，那么就应当进行以下几点保证：</p>
<ul>
<li><p>可观测性（observability）设计：监控、告警、日志、追踪；</p>
</li>
<li><p>可靠性（Reliability）设计：冗余设计、分区分配设计、复制算法设计、幂等性设计、一致性算法设计；</p>
</li>
<li><p>容量（capacity）规划设计：计算机节点资源资源有限，就需要分布式系统进行进行容量规划；</p>
</li>
<li><p>服务治理（Service governance）设计：CPU算力有限、内存有限、网卡吞吐量有限、磁盘IO有限，因此需要进行服务治理之隔板设计以及限流、限并发设计。</p>
</li>
</ul>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>分布式系统是基于不同的网络上的系统，网络是分布式系统的连接方式之一，连接一台计算机的系统就是单机系统，连接两台计算机的系统就是镜像系统，连接三台及以上数目的计算机的系统就是分布式系统，因此分布式系统也继承了网络的原生缺点，即：</p>
<ul>
<li>网络是不可靠的；</li>
<li>网络是会出故障的；</li>
<li>网络是有时延的；</li>
<li>网络是会抖动的；</li>
<li>网络是不安全的；</li>
<li>网络是会丢包的；</li>
<li>网络是有带宽限制的；</li>
<li>网络消息是会乱序的；</li>
</ul>
<p>由此，为了保证分布式系统的服务质量：性能、可用性、可靠性、安全性等，那么就需要进行服务质量保证设计，其可以划分为：</p>
<ul>
<li><p>网络是不可靠以及会出现断网之类的故障的，因此分布式系统需要进行服务治理容错设计；</p>
</li>
<li><p>网络乱序以及丢包，因此分布式系统需要幂等性算法设计、端到端的校验算法设计；</p>
</li>
<li><p>网络带宽有限，因此分布式系统需要网络容量设计以及服务治理限流设计；</p>
</li>
<li><p>网络不安全：因此分布式系统需要服务安全设计；</p>
</li>
<li><p>网络是有时延的，因此分布式系统需要进行性能设计：更好的硬件、跟短的IO路径；</p>
</li>
<li><p>网络是会抖动的，因此分布式系统需要进行服务治理容错之超时处理设计。</p>
</li>
</ul>
<h2 id="协同"><a href="#协同" class="headerlink" title="协同"></a>协同</h2><blockquote>
<p>协同是指：“谐调一致，和合共同，协调两个或者两个以上的不同资源或者个体，一致地完成某一共同目标“，这些组件通过相互传递消息来进行通信和协调其动作，且彼此相互交互以完成一个共同的任务目标</p>
</blockquote>
<p>协同又可以拆分为协调动作与共同完成任务，即：</p>
<h4 id="协调动作"><a href="#协调动作" class="headerlink" title="协调动作"></a>协调动作</h4><p>分布式系统的组件通过传递消息进行通信及协调其动作，即：因此依据消息传递的特性以及缺点需要进行相应的协调动作设计：</p>
<ul>
<li>传递消息特性意味着需要进行RPC调用设计；</li>
<li>网络里传递的消息是经常不一样的，因此需要序列化编解码设计；</li>
<li>消息传递具有丢消息、丢处理的弊端，为了解决这个弊端就需要进行 ：幂等性设计、事务处理设计、日志设计；</li>
<li>消息的传递是会超时的，因此就需要服务治理容错之超时处理设计；</li>
<li>消息是基于网络传输的，而网络是可能随时出故障的，因此需要对消息进行可观测性设计即消息追踪设计；</li>
<li>需要知道消息从哪里来，往哪里去就需要一个配置中心管理集群各个计算机的信息，比如IP，因此需要进行配置中心设计；</li>
<li>光知道可以发往哪里还不够，还要知道发往的节点是活着的可服务的，需要知道计算机节点的服务状态，还需要保证消息路由的负载均衡，因此这就就需要一个协调的服务注册中心，进行服务组件的注册与心跳检测、消息路由以及按集群视图变更算法管理集群状态表，那么就需要注册中心设计、注册算法设计、负载均衡算法设计，心跳算法设计、集群视图变更算法设计以及集群状态表管理设计。</li>
</ul>
<h4 id="共同完成任务"><a href="#共同完成任务" class="headerlink" title="共同完成任务"></a>共同完成任务</h4><p>分布式系统的组件是通过相互交互以完成一个共同的任务目标，因此需要解决共同完成任务并且保证任务完成质量带来的难题：</p>
<ul>
<li><p>整个分布式系统需要能接收任务以及返回完成的任务，那么就需要有提供服务的能力，需要有服务调用接口设计，服务调用客户端以及可视化界面；</p>
</li>
<li><p>为了能让网络里的N台计算机相互交互完成一个共同的目标，就需要对任务进行拆分以及聚合设计；</p>
</li>
<li>任务拆分后要能知道发给哪个节点，那么就需要一个配置中心, 从配置中心获取目标节点信息；</li>
<li>任务拆分后分发给节点同时要保证处理的性能，那么就需要进行可伸缩性设计，一台机器处理不过来就需要N台机器一起处理从而保证处理的性能质量，因此又衍生出需要路由算法设计或分区分配算法设计，这样拆分后的任务可以被分发到不同的独立的节点进行处理，并且，但一个节点不可用时，还可以分发到其他的可用的节点，从而提升了系统性能与可用性；</li>
<li>任务又可以分为计算任务与存储任务，如果是存储任务，为了保证数据的可用性以及可靠性，就需要对分区进行冗余设计，即节点副本设计，如果需要节点副本设计又引入了选主算法设计、数据一致性复制算法设计与幂等性设计；</li>
<li>为了解决选主与复制一致性问题，又出现了PAXOS,RAFT,2PC,3PC 等，这样的基础一致性协议算法。</li>
</ul>
<p>至此，依据分布式的公理化公式：<font color="#00CED1"><strong>“分布式系统 = 计算机 + 网络 + 协同”</strong></font>，推导出了分布式的定理化推论，解读了分布式系统里为什么需要进行这些功能与非功能设计的问题，接下来还需要讲述分布式系统的度量。</p>
<h2 id="分布式系统的度量"><a href="#分布式系统的度量" class="headerlink" title="分布式系统的度量"></a><font color="#FF8C00">分布式系统的度量</font></h2><p>分布式系统是依据分布式公理定义的质量进行度量的，其涵盖以下几项内容：</p>
<ul>
<li><p>合适的性能（Performant），性能指标一般包括 TPS, QPS, Latency, IOPS， response time等，这里用”合适的性能“作为表达，指的是性能合适即可、够用即可，高性能当然好，但是高性能也意味着更高的成本，有些场景高性能反而是一种浪费行为，性能需求需要理解业务场景适可而止；</p>
</li>
<li><p>可用性(Availability)，可用性指的是系统长时间可对外提供服务的能力，通常采用小数点后的9的个数作为度量指标，按照这种约定“五个九”等于0.99999（或99.999％）的可用性，默认企业级达标的可用性为6个9。但是当前从时间维度来度量可用性已经没有太大的意义，因为设计得好的系统可以在系统出现故障得情况下也能保证对外提供得服务不中断，因此，当前更合适得可用性度量指标 是请求失败率；</p>
</li>
<li><p>可靠性(Reliability)，可靠性一般指系统在一定时间内、在一定条件下可以无故障地执行指定功能的能力或可能性， 也是采用小数点后的9的个数作为度量指标，通常5个9的可靠性就可以满足企业级达标；</p>
</li>
<li><p>可伸缩性(Scalability)，是指通过向系统添加资源来处理越来越多的工作并且维持高质量服务的能力，其受可用性以及可靠性的制约，集群规模越大出故障的概率越高从而降低可用性、可靠性，为了保证可用性以及可靠性达标，需要适配合理的可伸缩性指标；</p>
</li>
<li><p>韧性(resilience)，通常也叫容错性（fault-tolerant），也就是健壮和强壮的意思，指的是系统的对故障与异常的处理能力，比如在软件故障、硬件故障、认为故障这样的场景下，系统还能保持正常工作的能力；</p>
</li>
<li><p>可观测性(Observability)，是一种设计理念，包括告警、监控、日志与跟踪，可以实时地更深入地观测系统内部的工作状态；</p>
</li>
<li><p>安全性（security），指的是阻止非授权使用，阻止非法访问以及使用，保护合法用户的资产的能力；</p>
</li>
<li><p>易用性（usability），指的是软件的使用难易程度，对于产品的易用性来说， 易用性不仅仅 是软件使用角度的易用，还包括安装、部署、升级上的易用,升值还包括硬件层面的易用，比如产品的外观，形状等；</p>
</li>
<li><p>可运维性（operability），可运维性指的是运维人员对系统进行运维操作的难易程度，主要包含以下几个方面的难以程度： 系统的部署、升级、修改、监控以及告警等；</p>
</li>
<li>可测试性（ testability），指的是单元测试，集成测试，打桩测试等的难易；</li>
<li>可维护性（Maintainability）， 指的是代码升级，部署，定位bug，添加功能的难易；</li>
<li>可扩展性（ extensibility）， 指的是未来增加新的功能与模块的难易；</li>
<li><p>可读性（ readability），指的是代码的易理解程度。</p>
</li>
<li><p>边界约束：集群规模、计算机的容量等物理资源的限制，以及客户、用户、团队的约束需求。</p>
</li>
</ul>
<p>依据这几项质量度量指标，可以保证分布式的“可解释、可复制、可预测”。其中要保证质量的核心思想是<strong>“共享资源、消除资源竞用性以及平衡负载。”</strong>，共享资源需要注册中心，消除资源竞用性就需要服务治理，平衡负载需要好的路由算法。</p>
<h2 id="分布式系统的反熵增与数据守恒"><a href="#分布式系统的反熵增与数据守恒" class="headerlink" title="分布式系统的反熵增与数据守恒"></a><font color="#FF8C00">分布式系统的反熵增与数据守恒</font></h2><h3 id="熵增"><a href="#熵增" class="headerlink" title="熵增"></a>熵增</h3><p>熵增定律是物理学的基本定律之一，其被定义为：</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">1, 熵（Entropy）是用以度量一个系统“内在的混乱程度”，即系统中的无效能量；<br>2, 熵增定律：在一个孤立系统里，如果没有外力做功，其总混乱度（熵）会不断增大；<br>3，熵增过程是一个自发的由有序向无序发展的过程并且具有必然性，为了保证有序就必须逆熵增做功。<br></code></pre></td></tr></table></figure>
<p>分布式系统也是一个孤立的系统，其中的网络与计算机节点（涵盖电源、主板、CPU、内存、网卡、硬盘等）等硬件会老化、会出故障，组件之间协同工作也会遇到负载过高、软件系统出现BUG等问题，这也是一个熵增的过程，并且因为熵增的必然性，分布式系统总是自发地或非自发地不断由有序走向无序，最终不可逆地走向失效不可用。为了保证分布式系统是有序可用的就必须逆熵增做功，即对其反熵增，分布式系统的反熵增过程与方法是：</p>
<ul>
<li>可运维设计：软硬件的部署与升级设计、可视化设计、可观测性（监控、告警、日志、追踪）设计；</li>
<li>可服务设计：由团队解决故障以及提供服务的支持；</li>
<li>服务治理设计：熔断、限流、降级、隔离、容错，触使分布式系统保持在有序状态；</li>
<li>智能化设计：参数自我优化、故障自我判断、工作负载自我预测等；</li>
<li>动态平衡设计：动态平衡是一种设计理念，有进有出；</li>
</ul>
<p>因此其中在分布式系统里将需要将可运维、可服务、可治理、可智能化、动态平衡的思想融合到架构设计与开发中。</p>
<h3 id="数据守恒"><a href="#数据守恒" class="headerlink" title="数据守恒"></a>数据守恒</h3><p>能量守恒定律也是物理学的基本定律之一，其被定义为：</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">1，能量既不会凭空产生，也不会凭空消失，它只会从一种形式转化为另一种形式，或者从一个物体转移到其它物体，<br>   而能量的总量保持不变；<br>2，孤立系统的总能量保持不变。<br></code></pre></td></tr></table></figure>
<p>在分布式系统里<strong>“数据”</strong>即是分布式系统的能量，因此参照“能量守恒”定义，这里我给分布式系统一个<strong>“数据守恒”</strong>定义：</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">孤立系统的总数据量保持不变。数据既不会凭空产生，也不会凭空消失，它只会从一种形式转化为另一种形式，<br>或者从一个物体转移到其它物体， 而数据的总量保持不变；<br></code></pre></td></tr></table></figure>
<p>依据上节的定理推导，我们知道分布式系统里网络是不可靠的、消息传递是不可靠的、计算机节点是不可靠的、磁盘是不可靠的、内存是不可靠的、软件组件是不可靠的等等，这些过程都会丢数据，因此为了保证分布式系统里的<strong>“数据守恒”</strong>就需要对分布式系统进行数据可靠性设计：即：</p>
<ul>
<li>分区设计、冗余设计、幂等性设计、端到端的校验设计、日志设计、事务处理设计，缓存的MESI设计等。</li>
</ul>
<p>因此在分布式系统里将也需要将<strong>“数据守恒”</strong>的思想融合到架构设计与开发中。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><font color="#FF8C00">小结</font></h2><p>本文以物理学思维挖掘分布式系统的本质，推导出了分布式系统为什么需要这样的设计的缘由，并且文中阐述了分布式系统的基础理论、功能非功能、反熵增与数据守恒。日拱一卒，功不唐捐，分享是最好的学习，与其跟随不如创新，希望这个知识点对大家有用。另作者能力与认知都有限，”我讲的，可能都是错的“，欢迎大家拍砖留念。</p>
<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a><font color="#FF8C00">作者简介</font></h2><p>常平，中科大硕，DELL EMC 资深首席工程师，曾就职于Marvell、AMD，主要从事Linux内核以及分布式产品的交付、架构设计以及开发工作。</p>
<h2 id="版权申明"><a href="#版权申明" class="headerlink" title="版权申明"></a><font color="#FF8C00">版权申明</font></h2><p>本文的版权协议为 CC-BY-NC-ND license：<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh</a></p>
<p>在遵循署名、非商业使用（以获利为准）以及禁止演绎的前提下可以自由阅读、分享、转发、复制、分发等。</p>

      
    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/distributed/" rel="tag"><i class="fas fa-tags"></i>distributed</a>
        
      </div>
      
    </footer>
  </article>
  
  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right" aria-label="下一页"></i></a>
  </nav>
  
  
</div>

          </div>
          
          
          
<aside class="sidebar" id="sidebar" >
  
  
<div class="info sidebar-item" id="info">
  
  <img class="author-avatar" src="/images/avatar.jpg" alt="常平">
  
  <h1 class="author-name">常平</h1>
  <h2 class="author-description">“分布式系统架构设计师”</h2>
  <div class="site-count">
    
    <div class="archives-count">
      <div class="site-count-title">全部</div>
      <div><a href="/archives">80</a></div>
    </div>
    
    
    
    <span class="site-count-divider divider">|</span>
    
    <div class="categories-count">
      <div class="site-count-title">分类</div>
      <div><a href="/categories">5</a></div>
    </div>
    
    
    
    <span class="site-count-divider divider">|</span>
    
    <div class="tags-count">
      <div class="site-count-title">标签</div>
      <div><a href="/tags">5</a></div>
    </div>
    
  </div>
  
</div>


  <div class="sidebar-sticky">
    
    
    <hr>
    <div class="social-link sidebar-item">
      <div><i class="far fa-address-card"></i>链接</p></div>
      <ul>
        
        <li><i class="fab fa-github"></i><a href="https://github.com/wuchangping" target="_blank">GitHub</a></li>
        
      </ul>
    </div>
    
    
  </div>
</aside>


          
        </div>
      </div>
    </main>
    
<footer id="footer" class="footer" style="background: #1D2D2D;">
  <div class="container">
    <div class="back-to-top">
      <button id="back-to-top"><i class="fas fa-angle-double-up" aria-label="回到顶部"></i></button>
    </div>
    <div class="footer-container">
      <div class="footer-left">
        <div class="copyright">
          <span class="author">常平</span><span class="year"><i class="far fa-copyright"></i>2017 - 2020</span>
        </div>
        
        <div class="busuanzi">
          <span id="busuanzi_container_site_pv"><i class="fas fa-eye" aria-label="站点点击量" aria-hidden="false"></i><span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv"><i class="fas fa-user" aria-label="站点用户数" aria-hidden="false"></i><span id="busuanzi_value_site_uv"></span></span><span id="busuanzi_container_page_pv"><i class="far fa-file-alt"></i><span id="busuanzi_value_page_pv" aria-label="页面点击量" aria-hidden="false"></span></span>
        </div>
        
      </div>
      <div class="footer-right">
        <div class="custom-info">
          
          PoweredBy<i class="fab fa-github-alt"></i><a href="https://github.com/wuchangping" target="_blank">GitHub</a>
          
        </div>
        <div class="powered-by">
          由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/AlynxZhou/hexo-theme-aria/" target="_blank">ARIA</a>
        </div>
      </div>
    </div>
  </div>
</footer>


  </body>
</html>
